---
layout: post
title: 回溯法方式解决实际问题
tags: Java Interview
---

## 题目描述

一个淘宝的订单中包含n(10>=n>=1)种商品A1，A2，...，An，每种商品数量分别为a1，a2，...，an个，记做{a1,a2,...,an}(ak>0)。订单在仓库生产过程中，仓库为了提升作业效率，会提前对热门组合商品进行预包装。假设这n个商品有m(9>=m>=1)个商品组合，每个组合bomk包含A1，A2，...，An的数量分别为{b1,b2,...,bn}(bk>=0,至少存在一个bk>0)。

举例如下：

订单包含A，B，C商品，数量为{2，3，1}，商品组合bom1{2，1，1}，bom2{1，1，0}，bom3{0，1，1}
对以上订单匹配给定商品组合，得到的可能匹配结果为：res1.匹配到组合1一套，剩余B商品；res2.匹配到组合2两套，组合3一套，不剩商品；  
现要求订单的最优匹配，最优匹配的原则为：1.匹配组合后，剩余商品种类数越少越好；2.在剩余商品种类数相同的情况下，匹配到的组合种类数越少越好；  
例如上面例子，我们认为res2优于res1。  

现需要编写程序，输入格式为：
n,m  
a1,a2,...,an  
bom1,b11,b12,...,b1n  
bom2,b21,b22,...,b2n  
....  
bomm,bm1,bm2,...,bmn  

输入数据的格式说明（数据间使用英文逗号分隔）：
第一行数据：n个商品，m个预包方案  
第二行数据：商品1个数，商品2个数，。。。，商品n个数  
第三行数据：bom1，商品1个数，商品2个数，。。。，商品n个数  
第n-1行数据：。。。。  
第n行数据：bomn，商品1个数，商品2个数，。。。，商品n个数  
针对输入数据找出最优匹配，输出最优匹配的组合及套数，比如针对上面的例子输出：  
match result:  
bom2*2
bom3*1

## 解题思路 - **回溯**

1. 尝试从现有订单中除去最大可能数量的组合1，逐渐减少取组合1的数量
2. 对于剩余订单除去最大可能数量的组合2，逐渐减少组合2的数量
3. 以此类推，直到最后一种组合
4. 评价当前匹配结果，若当前匹配结果较优，则更新最优结果

- 优化

若前n项已经不在匹配结果中出现，且n超过之前最优结果中的剩余商品种类，则可以直接终止程序，之前保存的匹配结果即为最优解

```java
package ali;

import java.util.*;

/**
 * Created by yzk on 2018/3/14.
 */
public class Main {

    private int n; // 商品数量
    private int m; // 组合数量
    List<Integer> order; // 商品订单
    Map<String, List<Integer>> boms;// 商品组合

    private int[] nums; // 组合所用数量
    private int[] best; // 最优组合数量
    private int rule1; // 规则1: 剩余商品种类
    private int rule2; // 规则2: 使用组合种类

    private boolean[] used; // 计算已经有多少个商品组合统计过所有情况，用于提前终止

    public Main(int n, int m, List<Integer> order, Map<String, List<Integer>> boms) {
        this.n = n;
        this.m = m;
        this.order = order;
        this.boms = boms;

        this.nums = new int[n];
        this.best = new int[n];
        this.rule1 = n;
        this.rule2 = 0;

        this.used = new boolean[m];
    }

    /**
     * 寻找最优解，并返回各商品组合使用数量
     *
     * @return
     */
    private Map<String, Integer> resolve() {
        Map<String, Integer> res = new HashMap<>();

        // 从第1中组合开始解析
        resolve(0);

        for (int i = 0; i < n; i++) {
            if (best[i] > 0) res.put("bom" + (i + 1), best[i]);
        }

        return res;
    }

    /**
     * 从第p+1及以后商品组合中对剩余商品寻找最优解
     *
     * @param p
     */
    private void resolve(int p) {
        // 如果已经统计过所有情况的商品组合超过rule1，则提前终止
        if (p > 0 && used[p - 1] && p - 1 > rule1) return;

        // 如果已经到达最后一个bom，统计当前剩余商品种类，并与之前最优解比较，如果剩余商品种类数量相同，计算匹配到的组合种类
        if (p >= boms.size()) {
            int r1 = remainTypes();
            int r2 = useBomNums();
            if (r1 < rule1 || (r1 == rule1 && r2 < rule2)) {
                rule1 = r1;
                rule2 = r2;
                for (int i = 0; i < m; i++) {
                    best[i] = nums[i];
                }
            }
            return;
        }

        List<Integer> bom = boms.get("bom" + (p + 1));
        int max = max(bom);
        for (int i = max; i >= 0; i--) {
            // 删除i个bom对应的商品
            changeOrder(bom, true, i);

            // 更新当前组合所用数量
            nums[p] = i;
            // 继续删除下一个bom
            resolve(p + 1);

            // 恢复原状，加入i个bom对应的商品
            changeOrder(bom, false, i);

            // 是否已经统计过包含该商品组合的所有情况
            if (i == 0) {
                if (p == 0 || used[p - 1]) {
                    used[p] = true;
                }
            }
        }
    }

    /**
     * 计算该组合最多可用数量
     *
     * @param bom
     * @return
     */
    private int max(List<Integer> bom) {
        int max = 0;
        while (true) {
            for (int i = 0; i < n; i++) {
                if (order.get(i) < (max + 1) * bom.get(i)) {
                    return max;
                }
            }
            max++;
        }
    }

    /**
     * 修改订单商品数量
     *
     * @param bom
     * @param isRemove true: 增加；false: 减少
     * @param k
     */
    private void changeOrder(List<Integer> bom, boolean isRemove, int k) {
        int t = 1; // 增加
        if (isRemove) t = -1; // 减少
        for (int i = 0; i < order.size(); i++) {
            order.set(i, order.get(i) + t * k * bom.get(i));
        }
    }

    /**
     * 统计剩余商品数量
     *
     * @return
     */
    private int remainTypes() {
        int count = 0;
        for (int i = 0; i < n; i++) {
            if (order.get(i) > 0) count++;
        }
        return count;
    }

    /**
     * 统计使用组合数量
     *
     * @return
     */
    private int useBomNums() {
        int count = 0;
        for (int i = 0; i < m; i++) {
            if (nums[i] > 0) count++;
        }
        return count;
    }

    /**
     * 输入样例
     * 3,3
     * 2,3,1
     * bom1,2,1,1
     * bom2,1,1,0
     * bom3,0,1,1
     * <p>
     * 输出样例
     * match result:
     * bom2*2
     * bom3*1
     */
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);

        // 输入商品数量、组合数量
        String line = in.nextLine();
        int n = Integer.parseInt(line.split(",")[0]);
        int m = Integer.parseInt(line.split(",")[1]);

        // 输入商品订单
        line = in.nextLine();
        String[] itemCnt = line.split(",");
        List<Integer> order = new ArrayList<>();
        for (int i = 0; i < n; i++) {
            order.add(Integer.parseInt(itemCnt[i]));
        }

        // 输入商品组合
        Map<String, List<Integer>> boms = new HashMap<String, List<Integer>>();
        for (int i = 0; i < m; i++) {
            line = in.nextLine();
            String[] bomInput = line.split(",");
            List<Integer> bomDetail = new ArrayList<>();

            for (int j = 1; j <= n; j++) {
                bomDetail.add(Integer.parseInt(bomInput[j]));
            }
            boms.put(bomInput[0], bomDetail);
        }

        in.close();

        Main main = new Main(n, m, order, boms);
        Map<String, Integer> res = main.resolve();

        System.out.println("match result:");
        for (String key : res.keySet()) {
            System.out.println(key + "*" + res.get(key));
        }
    }
}

/*
3,3
2,3,1
bom1,2,1,1
bom2,1,1,0
bom3,0,1,1

match result:
bom2*2
bom3*1
* */

/*
4,4
2,4,8,16
bom1,1,2,4,7
bom2,1,2,0,0
bom3,0,0,1,5
bom4,0,0,1,1

match result:
bom4*6
bom2*2
bom3*2
* */

/*
5,5
3,7,4,2,8
bom1,1,2,1,0,3
bom2,1,1,0,1,0
bom3,0,1,0,0,2
bom4,0,1,1,0,1
bom5,1,1,0,0,4

match result:
bom4*4
bom5*1
bom2*2
* */
```